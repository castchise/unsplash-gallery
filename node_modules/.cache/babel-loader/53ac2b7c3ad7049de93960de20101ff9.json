{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar base83_1 = require(\"./base83\");\n\nvar utils_1 = require(\"./utils\");\n\nvar error_1 = require(\"./error\");\n\nvar bytesPerPixel = 4;\n\nvar multiplyBasisFunction = function multiplyBasisFunction(pixels, width, height, basisFunction) {\n  var r = 0;\n  var g = 0;\n  var b = 0;\n  var bytesPerRow = width * bytesPerPixel;\n\n  for (var x = 0; x < width; x++) {\n    for (var y = 0; y < height; y++) {\n      var basis = basisFunction(x, y);\n      r += basis * utils_1.sRGBToLinear(pixels[bytesPerPixel * x + 0 + y * bytesPerRow]);\n      g += basis * utils_1.sRGBToLinear(pixels[bytesPerPixel * x + 1 + y * bytesPerRow]);\n      b += basis * utils_1.sRGBToLinear(pixels[bytesPerPixel * x + 2 + y * bytesPerRow]);\n    }\n  }\n\n  var scale = 1 / (width * height);\n  return [r * scale, g * scale, b * scale];\n};\n\nvar encodeDC = function encodeDC(value) {\n  var roundedR = utils_1.linearTosRGB(value[0]);\n  var roundedG = utils_1.linearTosRGB(value[1]);\n  var roundedB = utils_1.linearTosRGB(value[2]);\n  return (roundedR << 16) + (roundedG << 8) + roundedB;\n};\n\nvar encodeAC = function encodeAC(value, maximumValue) {\n  var quantR = Math.floor(Math.max(0, Math.min(18, Math.floor(utils_1.signPow(value[0] / maximumValue, 0.5) * 9 + 9.5))));\n  var quantG = Math.floor(Math.max(0, Math.min(18, Math.floor(utils_1.signPow(value[1] / maximumValue, 0.5) * 9 + 9.5))));\n  var quantB = Math.floor(Math.max(0, Math.min(18, Math.floor(utils_1.signPow(value[2] / maximumValue, 0.5) * 9 + 9.5))));\n  return quantR * 19 * 19 + quantG * 19 + quantB;\n};\n\nvar encode = function encode(pixels, width, height, componentX, componentY) {\n  if (componentX < 1 || componentX > 9 || componentY < 1 || componentY > 9) {\n    throw new error_1.ValidationError(\"BlurHash must have between 1 and 9 components\");\n  }\n\n  if (width * height * 4 !== pixels.length) {\n    throw new error_1.ValidationError(\"Width and height must match the pixels array\");\n  }\n\n  var factors = [];\n\n  var _loop_1 = function _loop_1(y) {\n    var _loop_2 = function _loop_2(x) {\n      var normalisation = x == 0 && y == 0 ? 1 : 2;\n      var factor = multiplyBasisFunction(pixels, width, height, function (i, j) {\n        return normalisation * Math.cos(Math.PI * x * i / width) * Math.cos(Math.PI * y * j / height);\n      });\n      factors.push(factor);\n    };\n\n    for (var x = 0; x < componentX; x++) {\n      _loop_2(x);\n    }\n  };\n\n  for (var y = 0; y < componentY; y++) {\n    _loop_1(y);\n  }\n\n  var dc = factors[0];\n  var ac = factors.slice(1);\n  var hash = \"\";\n  var sizeFlag = componentX - 1 + (componentY - 1) * 9;\n  hash += base83_1.encode83(sizeFlag, 1);\n  var maximumValue;\n\n  if (ac.length > 0) {\n    var actualMaximumValue = Math.max.apply(Math, ac.map(function (val) {\n      return Math.max.apply(Math, val);\n    }));\n    var quantisedMaximumValue = Math.floor(Math.max(0, Math.min(82, Math.floor(actualMaximumValue * 166 - 0.5))));\n    maximumValue = (quantisedMaximumValue + 1) / 166;\n    hash += base83_1.encode83(quantisedMaximumValue, 1);\n  } else {\n    maximumValue = 1;\n    hash += base83_1.encode83(0, 1);\n  }\n\n  hash += base83_1.encode83(encodeDC(dc), 4);\n  ac.forEach(function (factor) {\n    hash += base83_1.encode83(encodeAC(factor, maximumValue), 2);\n  });\n  return hash;\n};\n\nexports.default = encode;","map":{"version":3,"sources":["../src/encode.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar base83_1 = require(\"./base83\");\nvar utils_1 = require(\"./utils\");\nvar error_1 = require(\"./error\");\nvar bytesPerPixel = 4;\nvar multiplyBasisFunction = function (pixels, width, height, basisFunction) {\n    var r = 0;\n    var g = 0;\n    var b = 0;\n    var bytesPerRow = width * bytesPerPixel;\n    for (var x = 0; x < width; x++) {\n        for (var y = 0; y < height; y++) {\n            var basis = basisFunction(x, y);\n            r +=\n                basis * utils_1.sRGBToLinear(pixels[bytesPerPixel * x + 0 + y * bytesPerRow]);\n            g +=\n                basis * utils_1.sRGBToLinear(pixels[bytesPerPixel * x + 1 + y * bytesPerRow]);\n            b +=\n                basis * utils_1.sRGBToLinear(pixels[bytesPerPixel * x + 2 + y * bytesPerRow]);\n        }\n    }\n    var scale = 1 / (width * height);\n    return [r * scale, g * scale, b * scale];\n};\nvar encodeDC = function (value) {\n    var roundedR = utils_1.linearTosRGB(value[0]);\n    var roundedG = utils_1.linearTosRGB(value[1]);\n    var roundedB = utils_1.linearTosRGB(value[2]);\n    return (roundedR << 16) + (roundedG << 8) + roundedB;\n};\nvar encodeAC = function (value, maximumValue) {\n    var quantR = Math.floor(Math.max(0, Math.min(18, Math.floor(utils_1.signPow(value[0] / maximumValue, 0.5) * 9 + 9.5))));\n    var quantG = Math.floor(Math.max(0, Math.min(18, Math.floor(utils_1.signPow(value[1] / maximumValue, 0.5) * 9 + 9.5))));\n    var quantB = Math.floor(Math.max(0, Math.min(18, Math.floor(utils_1.signPow(value[2] / maximumValue, 0.5) * 9 + 9.5))));\n    return quantR * 19 * 19 + quantG * 19 + quantB;\n};\nvar encode = function (pixels, width, height, componentX, componentY) {\n    if (componentX < 1 || componentX > 9 || componentY < 1 || componentY > 9) {\n        throw new error_1.ValidationError(\"BlurHash must have between 1 and 9 components\");\n    }\n    if (width * height * 4 !== pixels.length) {\n        throw new error_1.ValidationError(\"Width and height must match the pixels array\");\n    }\n    var factors = [];\n    var _loop_1 = function (y) {\n        var _loop_2 = function (x) {\n            var normalisation = x == 0 && y == 0 ? 1 : 2;\n            var factor = multiplyBasisFunction(pixels, width, height, function (i, j) {\n                return normalisation *\n                    Math.cos((Math.PI * x * i) / width) *\n                    Math.cos((Math.PI * y * j) / height);\n            });\n            factors.push(factor);\n        };\n        for (var x = 0; x < componentX; x++) {\n            _loop_2(x);\n        }\n    };\n    for (var y = 0; y < componentY; y++) {\n        _loop_1(y);\n    }\n    var dc = factors[0];\n    var ac = factors.slice(1);\n    var hash = \"\";\n    var sizeFlag = componentX - 1 + (componentY - 1) * 9;\n    hash += base83_1.encode83(sizeFlag, 1);\n    var maximumValue;\n    if (ac.length > 0) {\n        var actualMaximumValue = Math.max.apply(Math, ac.map(function (val) { return Math.max.apply(Math, val); }));\n        var quantisedMaximumValue = Math.floor(Math.max(0, Math.min(82, Math.floor(actualMaximumValue * 166 - 0.5))));\n        maximumValue = (quantisedMaximumValue + 1) / 166;\n        hash += base83_1.encode83(quantisedMaximumValue, 1);\n    }\n    else {\n        maximumValue = 1;\n        hash += base83_1.encode83(0, 1);\n    }\n    hash += base83_1.encode83(encodeDC(dc), 4);\n    ac.forEach(function (factor) {\n        hash += base83_1.encode83(encodeAC(factor, maximumValue), 2);\n    });\n    return hash;\n};\nexports.default = encode;\n//# sourceMappingURL=encode.js.map"]},"metadata":{},"sourceType":"script"}